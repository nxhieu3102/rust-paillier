pub mod serialize;
pub mod primesample;
pub mod paillier;
pub mod optimized_paillier;

use std::panic;
pub use curv::arithmetic::BigInt;
use wasm_bindgen::prelude::wasm_bindgen;
pub use primesample::*;
use crate::optimized_paillier::*;
use serde_json::json;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn ngen(n: i32, b: i32) -> JsValue {
    panic::set_hook(Box::new(console_error_panic_hook::hook));

    let (ek, dk) = OptimizedPaillier::ngen(n, b).keys();

    let result = json!({
        "encryptionKey": ek,
        "decryptionKey": dk
    });

    serde_wasm_bindgen::to_value(&result).unwrap()
}

#[link(wasm_import_module = "env")]
extern "C" {
    pub fn ___gmpz_sizeinbase(x: *const i32, base: i32) -> i32;
    pub fn ___gmpz_init(x: *mut i32);
    pub fn ___gmpz_clear(x: *mut i32);
    pub fn ___gmpz_get_str(str_ptr: *mut u8, base: i32, x: *const i32) -> *mut u8;
    pub fn __gmpz_add(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn __gpmz_mul(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn __gmpz_sub(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn __gmpz_mod(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn __gmpz_powm(res: *mut i32, base: *const i32, exp: *const i32, modu: *const i32);
    pub fn __gmpz_cmp(op1: *const i32, op2: *const i32) -> i32;
    pub fn __gmpz_tdiv_q(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn __gmpz_tdiv_r(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn __gmpz_add_ui(res: *mut i32, op1: *const i32, op2: i32);
    pub fn __gmpz_addmul(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_abs(res: *mut i32, op: *const i32);
    pub fn ___gmpz_add(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_add_ui(res: *mut i32, op1: *const i32, op2: i32);
    pub fn ___gmpz_addmul(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_submul(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_addmul_ui(res: *mut i32, op1: *const i32, op2: i32);
    pub fn ___gmpz_aorsmul_1(res: *mut i32, op1: *const i32, op2: i32);
    pub fn ___gmpz_submul_ui(res: *mut i32, op1: *const i32, op2: i32);
    pub fn ___gmpz_and(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_array_init(res: *mut i32, n: i32, init_val: i32);
    pub fn ___gmpz_bin_ui(res: *mut i32, op1: *const i32, op2: i32);
    pub fn ___gmpz_bin_uiui(res: *mut i32, op1: i32, op2: i32);
    pub fn ___gmpz_cdiv_q(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_cdiv_q_ui(res: *mut i32, op1: *const i32, op2: i32);
    pub fn ___gmpz_cdiv_qr(q: *mut i32, r: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_cdiv_qr_ui(q: *mut i32, r: *mut i32, op1: *const i32, op2: i32);
    pub fn ___gmpz_cdiv_r(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_cdiv_r_ui(res: *mut i32, op1: *const i32, op2: i32);
    pub fn ___gmpz_cdiv_ui(op1: *const i32, op2: i32) -> i32;
    pub fn ___gmpz_cdiv_q_2exp(res: *mut i32, op1: *const i32, exp: i32);
    pub fn ___gmpz_fdiv_q_2exp(res: *mut i32, op1: *const i32, exp: i32);
    pub fn ___gmpz_cdiv_r_2exp(res: *mut i32, op1: *const i32, exp: i32);
    pub fn ___gmpz_fdiv_r_2exp(res: *mut i32, op1: *const i32, exp: i32);
    pub fn ___gmpz_clears(x: *mut i32, ...);
    pub fn ___gmpz_clrbit(x: *mut i32, bit_index: i32);
    pub fn ___gmpz_cmp_d(op1: *const i32, op2: f64) -> i32;
    pub fn ___gmpz_cmp_si(op1: *const i32, op2: i32) -> i32;
    pub fn ___gmpz_cmp_ui(op1: *const i32, op2: u32) -> i32;
    pub fn ___gmpz_cmpabs(op1: *const i32, op2: *const i32) -> i32;
    pub fn ___gmpz_cmpabs_d(op1: *const i32, op2: f64) -> i32;
    pub fn ___gmpz_cmpabs_ui(op1: *const i32, op2: u32) -> i32;
    pub fn ___gmpz_com(res: *mut i32, op: *const i32);
    pub fn ___gmpz_combit(x: *mut i32, bit_index: i32);
    pub fn ___gmpz_congruent_p(op1: *const i32, op2: *const i32, mod_: *const i32) -> i32;
    pub fn ___gmpz_congruent_2exp_p(op1: *const i32, op2: *const i32, exp: i32) -> i32;
    pub fn ___gmpz_congruent_ui_p(op1: *const i32, op2: u32, mod_: u32) -> i32;
    pub fn ___gmpz_divexact(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_divexact_gcd(res: *mut i32, op1: *const i32, op2: *const i32, gcd: *const i32);
    pub fn ___gmpz_divexact_ui(res: *mut i32, op1: *const i32, op2: u32);
    pub fn ___gmpz_divisible_p(op1: *const i32, op2: *const i32) -> i32;
    pub fn ___gmpz_divisible_ui_p(op1: *const i32, op2: u32) -> i32;
    pub fn ___gmpz_divisible_2exp_p(op1: *const i32, exp: i32) -> i32;
    pub fn ___gmpz_dump(op: *const i32);
    pub fn ___gmpz_export(res: *mut u8, countp: *mut usize, order: i32, size: usize, endian: i32, nails: usize, op: *const i32);
    pub fn ___gmpz_mfac_uiui(res: *mut i32, op1: u32, op2: u32);
    pub fn ___gmpz_2fac_ui(res: *mut i32, op: u32);
    pub fn ___gmpz_fac_ui(res: *mut i32, op: u32);
    pub fn ___gmpz_oddfac_1(res: *mut i32, op: u32);
    pub fn ___gmpz_prodlimbs(res: *mut i32, op: *const i32, n: usize);
    pub fn ___gmpz_fdiv_q_ui(res: *mut i32, op1: *const i32, op2: u32);
    pub fn ___gmpz_fdiv_qr(q: *mut i32, r: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_fdiv_qr_ui(q: *mut i32, r: *mut i32, op1: *const i32, op2: u32);
    pub fn ___gmpz_fdiv_r(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_fdiv_r_ui(res: *mut i32, op1: *const i32, op2: u32);
    pub fn ___gmpz_fdiv_q(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_fdiv_ui(op1: *const i32, op2: u32) -> u32;
    pub fn ___gmpz_fib_ui(res: *mut i32, n: u32);
    pub fn ___gmpz_fib2_ui(fn_: *mut i32, fn1: *mut i32, n: u32);
    pub fn ___gmpz_fits_sint_p(op: *const i32) -> i32;
    pub fn ___gmpz_fits_slong_p(op: *const i32) -> i32;
    pub fn ___gmpz_fits_sshort_p(op: *const i32) -> i32;
    pub fn ___gmpz_fits_uint_p(op: *const i32) -> i32;
    pub fn ___gmpz_fits_ulong_p(op: *const i32) -> i32;
    pub fn ___gmpz_fits_ushort_p(op: *const i32) -> i32;
    pub fn ___gmpz_gcd(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_gcd_ui(res: *mut i32, op1: *const i32, op2: u32) -> u32;
    pub fn ___gmpz_gcdext(g: *mut i32, s: *mut i32, t: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_get_d(op: *const i32) -> f64;
    pub fn ___gmpz_get_d_2exp(exp: *mut i32, op: *const i32) -> f64;
    pub fn ___gmpz_get_si(op: *const i32) -> i32;
    pub fn ___gmpz_get_ui(op: *const i32) -> u32;
    pub fn ___gmpz_getlimbn(op: *const i32, n: usize) -> u32;
    pub fn ___gmpz_hamdist(op1: *const i32, op2: *const i32) -> u32;
    pub fn ___gmpz_import(res: *mut i32, count: usize, order: i32, size: usize, endian: i32, nails: usize, op: *const u8);
    pub fn ___gmpz_init2(x: *mut i32, n: u32);
    pub fn ___gmpz_inits(x: *mut i32, ...);
    pub fn ___gmpz_inp_raw(res: *mut i32, stream: *mut i32) -> usize;
    pub fn ___gmpz_inp_str(res: *mut i32, stream: *mut i32, base: i32) -> i32;
    pub fn ___gmpz_inp_str_nowhite(res: *mut i32, stream: *mut i32, base: i32) -> i32;
    pub fn ___gmpz_invert(res: *mut i32, op1: *const i32, op2: *const i32) -> i32;
    pub fn ___gmpz_ior(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_init_set(res: *mut i32, op: *const i32);
    pub fn ___gmpz_init_set_d(res: *mut i32, op: f64);
    pub fn ___gmpz_init_set_si(res: *mut i32, op: i32);
    pub fn ___gmpz_init_set_str(res: *mut i32, str: *const u8, base: i32) -> i32;
    pub fn ___gmpz_init_set_ui(res: *mut i32, op: u32);
    pub fn ___gmpz_jacobi(op1: *const i32, op2: *const i32) -> i32;
    pub fn ___gmpz_si_kronecker(op1: i32, op2: *const i32) -> i32;
    pub fn ___gmpz_ui_kronecker(op1: u32, op2: *const i32) -> i32;
    pub fn ___gmpz_kronecker_si(op1: *const i32, op2: i32) -> i32;
    pub fn ___gmpz_kronecker_ui(op1: *const i32, op2: u32) -> i32;
    pub fn ___gmpz_lcm(res: *mut i32, op1: *const i32, op2: *const i32);
    pub fn ___gmpz_lcm_ui(res: *mut i32, op1: *const i32, op2: u32);
    pub fn ___gmpz_limbs_finish(op: *mut i32, n: usize);
    pub fn ___gmpz_limbs_modify(op: *mut i32, n: usize);
    pub fn ___gmpz_limbs_read(op: *const i32, n: usize);
    pub fn ___gmpz_limbs_write(op: *mut i32, n: usize);
    pub fn ___gmpz_lucas_mod(res: *mut i32, n: u32, mod_: *const i32);
    pub fn ___gmpz_lucnum_ui(res: *mut i32, n: u32);
    pub fn ___gmpz_lucnum2_ui(fn_: *mut i32, fn1: *mut i32, n: u32);
    pub fn ___gmpz_millerrabin(op: *const i32, reps: i32) -> i32;
    pub fn ___gmpz_mul_2exp(res: *mut i32, op: *const i32, exp: i32);
    pub fn ___gmpz_mul_si(res: *mut i32, op1: *const i32, op2: i32);
    pub fn ___gmpz_mul_ui(res: *mut i32, op1: *const i32, op2: u32);
    pub fn ___gmpz_n_pow_ui(res: *mut i32, op: *const i32, exp: u32);
    pub fn ___gmpz_neg(res: *mut i32, op: *const i32);
    pub fn ___gmpz_nextprime(res: *mut i32, op: *const i32);
    pub fn ___gmpz_prevprime(res: *mut i32, op: *const i32);
    pub fn ___gmpz_out_raw(stream: *mut i32, op: *const i32) -> usize;
    pub fn ___gmpz_out_str(stream: *mut i32, base: i32, op: *const i32) -> i32;
    pub fn ___gmpz_perfect_power_p(op: *const i32) -> i32;
    pub fn ___gmpz_perfect_square_p(op: *const i32) -> i32;
    pub fn ___gmpz_popcount(op: *const i32) -> u32;
    pub fn ___gmpz_pow_ui(res: *mut i32, base: *const i32, exp: u32);
    pub fn ___gmpz_powm_sec(res: *mut i32, base: *const i32, exp: *const i32, mod_: *const i32);
    pub fn ___gmpz_powm_ui(res: *mut i32, base: *const i32, exp: u32, mod_: *const i32);
    pub fn ___gmpz_primorial_ui(res: *mut i32, n: u32);
    pub fn ___gmpz_probab_prime_p(op: *const i32, reps: i32) -> i32;
    pub fn ___gmpz_random(res: *mut i32, state: *mut i32, n: i32);
    pub fn ___gmpz_random2(res: *mut i32, n: i32);
    pub fn ___gmpz_realloc(op: *mut i32, n: usize);
    pub fn ___gmpz_realloc2(op: *mut i32, n: usize);
    pub fn ___gmpz_remove(res: *mut i32, op: *const i32, factor: *const i32) -> u32;
    pub fn ___gmpz_roinit_n(res: *mut i32, op: *const i32, n: usize);
    pub fn ___gmpz_root(res: *mut i32, op: *const i32, n: i32) -> i32;
    pub fn ___gmpz_rootrem(res: *mut i32, rem: *mut i32, op: *const i32, n: i32) -> i32;
}